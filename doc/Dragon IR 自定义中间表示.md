# Dragon IR 自定义中间表示

## 标识符

### 全局变量

@ 开头，后跟原始的全局变量名

例如 declare i32 @name

### 局部变量

%l 开头，后跟数字做区分

例如 declare i32 %l1

在栈内分配空间

### 临时变量

%t 开头，后跟数字做区分

例如 declare i32 %t1

不在栈内分配空间

### 标签

.L 开头，后跟数字

例如 .L1

### 函数名

@开头

例如 

**@开头的符号是全局符号，注意不可重复定义**

## 常量或字面量

整形常量就直接以数字显示

例如 123

## 类型

基本类型有

- i32 32位int类型
- i8 8位int类型，相当于char
- i1 1位int类型，相当于bool
- void
- i32 * i32指针
- i8 * i8指针

## 注释

仅支持单行注释，以 ; 开始到行末的内容都是注释

## 变量定义

以 declare 开头，后跟类型，后跟标识符

例如 declare i32 @f2

全局变量的定义需放在IR文件的头部，第一个函数定义的前面

函数内的局部变量和编译器生成的临时变量在函数体的开始部分声明，且在第一条入口指令的前面

## 变量赋值

@a=3

%t0=@a

约定临时变量不能赋值给临时变量，常量不能赋值给临时变量

## 指针操作 & 内存操作

形式定义：变量 = * 变量

功能：从右侧变量（指针变量）所指向的内存中获取值赋值给左侧的变 量（如左值的临时变量）

形式定义： *变量 = 变量

功能：把右侧的变量值保存到左侧变量（指针变量）所指向的内存中

## 二元算数运算

格式：变量1 = 算术运算符 变量2, 变量3

算术运算符：

- add
- sub
- mul
- div
- mod

add和sub指令还允许右侧变量一个为指针类型变量，一个为基 本类型变量，结果为指针类型变量

特别说明，add或sub指令可用于类似指针的加整型变量的偏移获取元素地址的功能，要求add或sub指令的第一个源操作数（逗号左侧的变量）是指针型变量或者数组首地址，第二个源操作数（都好右侧的变量）是整型的临时变量或常量，局部变量不建议。

## 表达式运算指令

### 一元算数指令 (求负运算)

变量1 = neg 变量2

### 关系运算

变量1 = cmp 比较运算符 变量2，变量3

比较运算符有，le: 小于等于    lt：小于   gt：大于    ge：大于等于   ne：不等于   eq：等于

### 逻辑运算

## 跳转指令

### Label指令

定义标签，格式为标识符加冒号

标识符用于定义Label名称，以.L开头的标识符。要求函数内唯一，不可重复

### 无条件跳转

br label 标识符

### 有条件跳转

bc condvar, label X, label Y

condvar条件临时变量，类型为i1； X为真跳转标签，Y假跳转标签；本指令表示若condvar为真，则跳转到X处执行，否则跳转到Y处执行。

## 数组

### 数组定义

示例

``int a[10][15];  ----->  declare i32 %l1[10`][15]``

### 一维数组访问

假设%l6代表变量m，%l2代表数组a，%l5代表变量k，数组元素类型为int

m = a[k] 可以翻译为： 

① %t10 = mul %l5, 4     ; 元素偏移转换成字节偏移 
② %t11 = add %l2, %t10  ; 数组元素首地址+偏移得到元素的字节位置 
③ %l6 = *%t11  ; 从内存中取值，假定取4个字节的数据

假设%l6代表变量m，%l2代表数组a，%l5代表变量k，数组元素类型为int

a[k] = m    翻译为： 

① %t10 = mul %l5, 4
② %t11 = add %l2, %t10 
③ *%t11=%l6

### 二维数组访问

读取二维数组

```c
int a[10][10];
int m, k, t;
t = a[m][k];
```

翻译为

```
declare i32 %l1[10][10]     ;数组a
declare i32 %l2                   ;变量m
declare i32 %l3                   ;变量k
declare i32 %l4                   ;变量t
declare i32 %t5
declare i32 %t6
declare i32 %t7             ;保存a[m][k]相对数组首地址的偏移，单位字节
declare i32* %t8            ;数组元素的位置，类型为指向i8的指针
%t5 = mul %l2, 10           
%t6 = add %t5, %l3
%t7 = mul %t6, 4             ;(m*10+k)*sizeof(int)
%t8 = add %l1, %t7         ; 数组元素首地址+元素的字节偏移后的指针
%l4 = *%t8                       ;从内存中获取i32类型的元素值

```

存数二维数组

```c
int a[10][10];
int m, k, t;
a[m][k] = t;
```

翻译为

```
declare i32 %l1[10][10]      ;数组a
declare i32 %l2                   ;变量m
declare i32 %l3                   ;变量k
declare i32 %l4                   ;变量t
declare i32 %t5
declare i32 %t6
declare i32 %t7
declare i32* %t8               ;数组元素的位置，类型为指向i8的指针
%t5 = mul %l2, 10           
%t6 = add %t5, %l3
%t7 = mul %t6, 4               ;(m*10+k)*sizeof(int)
%t8 = add %l1, %t7           ; 数组元素首地址+元素的字节偏移后的指针
*%t8 = %l4                        ;把t的值设置到%t8所指向的内存中
```

## 函数定义

### 入口指令

格式:entry

函数的入口。每个函数有且只有一个。必须存在，用于表示函数的第一条有效指令。放置在declare语句指令的后面，其它指令的前面。

### 出口指令

格式：exit 变量

格式：exit 常量

格式：exit

函数的出口指令。每个函数只能有一个出口。只存在于函数的最尾部。必须存在。这里的变量或常量是函数的返回值

### return 的翻译

函数进行返回时，要事先创建一个用于保存返回值的局部变量（称为返回值局部变量）和一个函数出口标签指令

函数出口标签指令放在函数的尾部，用于MiniC语言的return语句的翻译时跳转到函数的出口，保持函数只有一个出口

### 形参处理

首先分配与形参对应的局部变量（将来用于在栈内分配空间），然后把原始的形参变成临时变量类型，在entry指令后把形参的值（临时变量）保存到对应的局部变量中。

### 示例: 函数定义翻译

```c
int test(int a, int b)
 {
 ...
      return 0;
 ...
      return 1;
 }
```

```
define i32 @test(i32 %t0, i32 %t1) {
declare i32 %l2      ;                返回值局部变量
declare i32 %l3      ;形参a对应的局部变量
declare i32 %l4     ; 形参b对应的局部变量
...
entry
%l3 = %t0    ;a赋值给a对应的局部变量
%l4 = %t1    ;b赋值给b对应的局部变量
                 ;后续所有对a和b的操作修改成对应的局部变量操作
... 
%l2 = 0
br .L1
... 
%l2 = 1
br .L1
.L1:                       ;函数出口标签
exit %l2
 }

```

### 函数调用

Dragon IR规定函数实参按照自左往右计算，实参结果按自右往左入栈

**示例：有返回值的函数调用**

```
 %t1 = %l1
 %t2 = %l2
 %t3 = call i32 @test(i32 %t1,i32 %t2)
 %l3 = %t3
```

**示例：无返回值的函数调用**

```
 %t1 = %l1
 call void @putint(i32 %t1)
```

## IR 示例